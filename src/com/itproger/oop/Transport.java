package com.itproger.oop;

public abstract class Transport {        //Абстрактный класс

    public float speed;
    public int weight;
    public String color;
    public byte[] coordinate;
    // Все переменные лучше делать либо private, либо protected. Доступ к переменным должен осуществляться только
    // за счёт методов и конструкторов. Доступ к полям напрямую должен быть закрыт

    public Transport() {}

    public Transport(float speed, int weight, String color, byte[] coordinate) {
// Join to DB
        this.speed = speed;
        this.weight = weight;
        this.color = color;
        this.coordinate = coordinate;
        System.out.println(this.getValues());
        System.out.println("Object created");
    }

    public void setValues(float speed, int weight, String color, byte[] coordinate) {
        this.speed = speed;
        this.weight = weight;
        this.color = color;
        this.coordinate = coordinate;
    }

    public String getValues() {
        String info = "Object speed: " + speed + ", Weight: " + weight + ", Color: " + color + ".\n";
        String infoCoordinates = "Coordinates: \n";
        for (int i = 0; i < coordinate.length; i++)
            infoCoordinates += coordinate[i] + "\n";
        return info + infoCoordinates;
    }

//Структура ООП, классы:
    /*Каждый файл в языке Java является классом, поэтому, чтобы создать очередной класс, необходимо создать новый файл
    в проекте. Название файла это и есть название класса
    Создав новый класс и поместив туда какую-либо информацию мы можем создавать на основе него новые объекты.
    Объекты будут иметь доступ ко всем характеристикам класса, которые отмечены модификатором public.

Существует три модификатора доступа:
public - данные будут видны повсюду, как в классе, так и вне его;
protected - данные будут видны только в классе, где они были созданы, а также в классах наследниках;
private - данные будут видны только в классе, где они были созданы.

    На основе такого класса мы можем создать множество объектов. Каждый объект в данном случае будет представлять
    собой конкретную книжку. Для каждого объекта мы можем указать уникальные данные: количество страниц,
    название книги и её вес.
    Чтобы брать данные из класса через объект, необходимо ставить точку и указывать имя переменной или функции,
    которую мы хотим взять. */

// Абстрактные классы:
    // Помимо обычных классов вы можете создавать абстрактные классы, что будут описывать лишь базовый функционал.
    // На их основе нельзя создать объекты, но зато в них можно прописать абстрактные методы.
    // Абстрактные классы очень схожи с обычными классами в Java. Единственное отличие заключаются в том, что
    // абстрактный класс ничего не реализует. Внутри него можно лишь указать все методы и поля, которые необходимо
    // реализовывать во всех классах наследниках.
    // Для создания абстрактных классов используется ключевое слово abstract:
    // В абстрактном классе можно создать методы как в интерфейсах или же можно прописать абстрактные методы,
    // что ничего из себя не представляют. Для создания абстрактного метода используйте ключевое слово abstract
    // перед указанием типа данных.
    // Классы наследники от абстрактного класса должны реализовывать все методы абстрактного класса,
    // иначе компилятор будет выдавать ошибки.
    // Подобные классы полезны, ведь можно указать лишь общий функционал, что должен присутствовать во всех классах
    // наследниках, но при этом какая именно будет реализация нам не известно.

    public abstract void moveObject(float speed);   //Абстрактный метод

// Вложенные классы:
    // За счет вложенных классов можно описать дополнительный объект, что принадлежит к классу
    // Вложенные классы можно прописывать внутри других классов. Такое зачастую используется, когда вложенный
    // класс дополняет основной класс и является его частью.
    // Создав вложенный класс вы можете прописать в нём дополнительные поля, методы и конструкторы и далее ссылаясь
    // на главный класс вы можете дополнительно ссылаться на класс наследник.

    class Engine {
        private boolean isReady;
        private int km;
        public void setValues(boolean isReady, int km) {
            this.isReady = isReady;
            this.km = km;
        }
        public void info() {
            if(isReady)
                System.out.println("Engine is working");
            else
                System.out.println("Engine passed " + km + "km");
        }
        public void isReady(boolean isReady) {
            this.isReady = isReady;
            // Это метод необходим, т.к. доступ к полю должен быть закрыт,
            // и мы будем обращаться через этот метод
        }
    }
}
